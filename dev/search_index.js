var documenterSearchIndex = {"docs":
[{"location":"Mapmake/#Mapmake","page":"Mapmake","title":"Mapmake","text":"","category":"section"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"Mapmaking is available for computing hitmap and crosslink maps.","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"ScanningStrategy2map(ss::ScanningStrategy, devide::Int)","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"This function splits the observation time specified by ScanningStrategy by the number specified by devide, calculates the pointing TOD, and then creates a map using it. The reason for the split calculation is to avoid overloading the memory by calculating a huge amount of pointing TOD data at once. Inside this function, get_pointing_pixels() is being executed.","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"For example,","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"outmap = ScanningStrategy2map(ss::ScanningStrategy, 12)","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"Now, the pointing TOD is calculated every month and stored in the map each time.","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"The outmap is a matrix, the contents of which are as follows.","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"outmap[1]: Hitmap\noutmap[2]: Crosslink map (n=1)\noutmap[3]: Crosslink map (n=2)\noutmap[4]: Crosslink map (n=3)\noutmap[5]: Crosslink map (n=4)","category":"page"},{"location":"Mapmake/","page":"Mapmake","title":"Mapmake","text":"The n is the spin, a measure to define the scan-derived systematic effect. It is described in detail in this paper.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/#Mapmake","page":"-","title":"Mapmake","text":"","category":"section"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"Mapmaking is available for computing hitmap and crosslink maps.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"ScanningStrategy2map(ss::ScanningStrategy, devide::Int)","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"This function splits the observation time specified by ScanningStrategy by the number specified by devide, calculates the pointing TOD, and then creates a map using it. The reason for the split calculation is to avoid overloading the memory by calculating a huge amount of pointing TOD data at once. Inside this function, get_pointing_pixels() is being executed.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"For example,","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"outmap = ScanningStrategy2map(ss::ScanningStrategy, 12)","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"Now, the pointing TOD is calculated every month and stored in the map each time.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"The outmap is a matrix, the contents of which are as follows.","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"outmap[1]: Hitmap\noutmap[2]: Crosslink map (n=1)\noutmap[3]: Crosslink map (n=2)\noutmap[4]: Crosslink map (n=3)\noutmap[5]: Crosslink map (n=4)","category":"page"},{"location":".ipynb_checkpoints/Mapmake-checkpoint/","page":"-","title":"-","text":"The n is the spin, a measure to define the scan-derived systematic effect. It is described in detail in this paper.","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"CurrentModule = Falcons","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/#Falcons","page":"Falcons","title":"Falcons","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"This is the documentation of Falcons(Fast Algorithm for Locus Computing ON the Sky), a package for fast simulation of satellite observations.","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"CMB polarimetric satellites such as LiteBIRD set up an appropriate scan strategy to reduce systematic errors, and Falcons can calculate all-sky hit maps, crosslink maps, etc. by simply setting the parameters of this scan strategy. It also supports observations with multi-channel detectors.","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/#Installation","page":"Falcons","title":"Installation","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"From the Julia REPL, run","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"import Pkg\nPkg.add(\"Falcons\")","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/#Tutorial","page":"Falcons","title":"Tutorial","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"The tutorial is available on the github page in jupyternotebook format. Please refer to here.","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/#Documentation","page":"Falcons","title":"Documentation","text":"","category":"section"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":".ipynb_checkpoints/index-checkpoint/","page":"Falcons","title":"Falcons","text":"Modules = [Falcons]","category":"page"},{"location":"Scanning/#Scanning-strategy","page":"Scanning","title":"Scanning strategy","text":"","category":"section"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"To define the scanning strategy for a satellite, set the ScanningStrategy structure.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"mutable struct ScanningStrategy{T<:AbstractFloat, I<:Int, AA<:AbstractArray{T}, AS<:AbstractString}\n    nside::I\n    times::I\n    sampling_rate::I\n    alpha::T\n    beta::T\n    prec_period::T\n    spin_rpm::T\n    hwp_rpm::T\n    FP_theta::AA\n    FP_phi::AA\n    start_point::AS\nend","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"To set it up, define constructor ss as follows.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"nside = 128\ntimes = year #[sec]\nsampling_rate = 1 #[Hz]\nFP_theta = [0.0] #The angle with respect to the boresight, 0 degree represents the boresight.\nFP_phi = [0.0]\nalpha = 55.0 #[degree]\nbeta = 60.0 #[degree]\nprec_period = 180.22 #[min]\nspin_rpm = 0.04 #[rpm]\nhwp_rpm = 0.05 #[rpm]\nstart_point = \"pole\" #You can choose \"pole\" or \"equator\"\n\nss = ScanningStrategy(\n    nside,\n    times,\n    sampling_rate,\n    alpha,\n    beta,\n    prec_period,\n    spin_rpm,\n    hwp_rpm,\n    FP_theta,\n    FP_phi,\n    start_point)","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"Once the ss is set, the internal values can be accessed and modified as follows","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"@show ss.nside #You can see a value\nss.nside = 256 #You can change a value","category":"page"},{"location":"Scanning/#Generate-pointing-TOD","page":"Scanning","title":"Generate pointing TOD","text":"","category":"section"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"The information about the orientation of a satellite at a certain time is called pointing. The pointing is defined by (theta phi psi), where theta and phi are parameters of the 3D polar coordinates and psi is the angle between the scan direction and the meridian of the sky.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"Once the scanning strategy is determined, computing the pointing is straightforward.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"theta_tod, phi_tod, psi_tod, time_array = get_pointings(ss::ScanningStrategy, start::Int, stop::Int)\npix_tod, psi_tod, time_array = get_pointing_pixels(ss::ScanningStrategy, start::Int, stop::Int)","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"Enter an integer value for the time to be calculated in the start and stop fields.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"theta_tod and phi_tod contain the pointing data in chronological order, and psi_tod contains the scan angle according to the COSMO(HEALPix) definition. And time_array contains the time used in the calculation.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"The return values of these two functions are tuples, and can be combined into a single variable as an array, as shown below. In this case, the values will be stored in the following order.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"pointing_TOD = get_pointings(ss::ScanningStrategy, start::Int, stop::Int)\n\npointing_TOD[1]: theta_tod\npointing_TOD[2]: phi_tod\npointing_TOD[3]: psi_tod\npointing_TOD[4]: time_array","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"get_pointing_pixels() does not allocate theta and phi arrays internally, but only allocates the minimum number of arrays needed to allocate the pixel TOD. Therefore, it runs faster than get_pointings(). In fact, get_pointing_pixels() is executed inside ScanningStrategy2map().","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"Now, the pointing TOD is calculated every month and stored in the map each time.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"ss.FP_theta = [0.0, 10.0]\nss.FP_phi = [0.0, 90.0]","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"In this operation, the first component of the array represents the center of the focal plane, i.e. the boresight. On the other hand, the second component represents the detector that observes a point in the sky 10 degrees in theta direction and 90 degrees in phi direction away from the boresight.","category":"page"},{"location":"Scanning/","page":"Scanning","title":"Scanning","text":"If you want to build a focal plane, just substitute its configuration into these arrays and you will be able to compute multi-channel pointing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Falcons","category":"page"},{"location":"#Falcons","page":"Home","title":"Falcons","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation of Falcons(Fast Algorithm for Locus Computing ON the Sky), a package for fast simulation of satellite observations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CMB polarimetric satellites such as LiteBIRD set up an appropriate scan strategy to reduce systematic errors, and Falcons can calculate all-sky hit maps, crosslink maps, etc. by simply setting the parameters of this scan strategy. It also supports observations with multi-channel detectors.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From the Julia REPL, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Falcons\")","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The tutorial is available on the github page in jupyternotebook format. Please refer to here.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Falcons]","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/#Scanning-strategy","page":"-","title":"Scanning strategy","text":"","category":"section"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"To define the scanning strategy for a satellite, set the ScanningStrategy structure.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"mutable struct ScanningStrategy{T<:AbstractFloat, I<:Int, AA<:AbstractArray{T}, AS<:AbstractString}\n    nside::I\n    times::I\n    sampling_rate::I\n    alpha::T\n    beta::T\n    prec_period::T\n    spin_rpm::T\n    hwp_rpm::T\n    FP_theta::AA\n    FP_phi::AA\n    start_point::AS\nend","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"To set it up, define constructor ss as follows.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"nside = 128\ntimes = year #[sec]\nsampling_rate = 1 #[Hz]\nFP_theta = [0.0] #The angle with respect to the boresight, 0 degree represents the boresight.\nFP_phi = [0.0]\nalpha = 55.0 #[degree]\nbeta = 60.0 #[degree]\nprec_period = 180.22 #[min]\nspin_rpm = 0.04 #[rpm]\nhwp_rpm = 0.05 #[rpm]\nstart_point = \"pole\" #You can choose \"pole\" or \"equator\"\n\nss = ScanningStrategy(\n    nside,\n    times,\n    sampling_rate,\n    alpha,\n    beta,\n    prec_period,\n    spin_rpm,\n    hwp_rpm,\n    FP_theta,\n    FP_phi,\n    start_point)","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"Once the ss is set, the internal values can be accessed and modified as follows","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"@show ss.nside #You can see a value\nss.nside = 256 #You can change a value","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/#Generate-pointing-TOD","page":"-","title":"Generate pointing TOD","text":"","category":"section"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"The information about the orientation of a satellite at a certain time is called pointing. The pointing is defined by (theta phi psi), where theta and phi are parameters of the 3D polar coordinates and psi is the angle between the scan direction and the meridian of the sky.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"Once the scanning strategy is determined, computing the pointing is straightforward.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"theta_tod, phi_tod, psi_tod, time_array = get_pointings(ss::ScanningStrategy, start::Int, stop::Int)\npix_tod, psi_tod, time_array = get_pointing_pixels(ss::ScanningStrategy, start::Int, stop::Int)","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"Enter an integer value for the time to be calculated in the start and stop fields.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"theta_tod and phi_tod contain the pointing data in chronological order, and psi_tod contains the scan angle according to the COSMO(HEALPix) definition. And time_array contains the time used in the calculation.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"The return values of these two functions are tuples, and can be combined into a single variable as an array, as shown below. In this case, the values will be stored in the following order.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"pointing_TOD = get_pointings(ss::ScanningStrategy, start::Int, stop::Int)\n\npointing_TOD[1]: theta_tod\npointing_TOD[2]: phi_tod\npointing_TOD[3]: psi_tod\npointing_TOD[4]: time_array","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"get_pointing_pixels() does not allocate theta and phi arrays internally, but only allocates the minimum number of arrays needed to allocate the pixel TOD. Therefore, it runs faster than get_pointings(). In fact, get_pointing_pixels() is executed inside ScanningStrategy2map().","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"Now, the pointing TOD is calculated every month and stored in the map each time.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"ss.FP_theta = [0.0, 10.0]\nss.FP_phi = [0.0, 90.0]","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"In this operation, the first component of the array represents the center of the focal plane, i.e. the boresight. On the other hand, the second component represents the detector that observes a point in the sky 10 degrees in theta direction and 90 degrees in phi direction away from the boresight.","category":"page"},{"location":".ipynb_checkpoints/Scanning-checkpoint/","page":"-","title":"-","text":"If you want to build a focal plane, just substitute its configuration into these arrays and you will be able to compute multi-channel pointing.","category":"page"}]
}
